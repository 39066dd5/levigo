<!DOCTYPE html>
<html>
  <head>
    <link rel="stylesheet" href="./bootstrap/css/bootstrap.min.css" type="text/css" media="screen" />
    <style type="text/css">
      code {
        padding: 3px 4px;
        color: #333;
        border: 1px solid #E1E1E8;
      }
    </style>
  </head>
  <body>
    <div class="container-fluid">
<!--
	Copyright 2009 The Go Authors. All rights reserved.
	Use of this source code is governed by a BSD-style
	license that can be found in the LICENSE file.
-->

	
		<div id="short-nav">
			<dl>
			<dd><code>import "github.com/jmhodges/levigo"</code></dd>
			</dl>
			<dl>
			<dd><a href="#overview">Overview</a></dd>
			<dd><a href="#index">Index</a></dd>
			
			
			</dl>
		</div>
		<h2 id="overview">Overview</h2>
		<!-- The package's Name is printed as title by the top-level template -->
		<p>
Package levigo provides the ability to create and access LevelDB databases.
</p>
<p>
levigo.Open() opens and creates databases.
</p>
<pre>opts := levigo.NewOptions()
opts.SetCache(levigo.NewLRUCache(3&lt;&lt;30))
opts.SetCreateIfMissing(true)
db, err := levigo.Open(&#34;/path/to/db&#34;, opts)
</pre>
<p>
*DB.Get(), .Put() and .Delete(), respectively, get the data related to a
single key, put data for a single key into the database, and deletes data for
a single key. Don&#39;t worry about copying the byte slices in the arguments and
return values of these methods; LevelDB will copy them for you.
</p>
<pre>ro := levigo.NewReadOptions()
wo := levigo.NewWriteOptions()
// if ro and wo are not used again, be sure to Close them.
data, err := db.Get(ro, []byte(&#34;key&#34;))
...
err = db.Put(wo, []byte(&#34;anotherkey&#34;), data)
...
err = db.Delete(wo, []byte(&#34;key&#34;))
</pre>
<p>
For bulk reads, use an Iterator. For ones that you do not want to disturb
your live traffic, be sure to call SetFillCache(false) on the ReadOptions you
use when creating the Iterator.
</p>
<pre>ro := levigo.NewReadOptions()
ro.SetFillCache(false)
it := db.NewIterator(ro)
defer it.Close()
it.Seek(mykey)
for it = it; it.Valid(); it.Next() {
	munge(it.Key(), it.Value())
}
</pre>
<p>
Batching and atomically making writes can be performed with a WriteBatch and
*DB.Write().
</p>
<pre>wb := levigo.NewWriteBatch()
// defer wb.Close() or use wb.Clear() and reuse.
wb.Delete([]byte(&#34;removed&#34;))
wb.Put([]byte(&#34;added&#34;), []byte(&#34;data&#34;))
wb.Put([]byte(&#34;anotheradded&#34;), []byte(&#34;more&#34;))
err := db.Write(wo, wb)
</pre>

		
	
		<h2 id="index">Index</h2>
		<!-- Table of contents for API; must be named manual-nav to turn off auto nav. -->
		<div id="manual-nav">
			<dl>
			
				<dd><a href="#constants">Constants</a></dd>
			
			
			
				
				<dd><a href="#DestroyComparator">func DestroyComparator(cmp *C.leveldb_comparator_t)</a></dd>
			
				
				<dd><a href="#DestroyDatabase">func DestroyDatabase(dbname string, o *Options) error</a></dd>
			
				
				<dd><a href="#RepairDatabase">func RepairDatabase(dbname string, o *Options) error</a></dd>
			
			
				
				<dd><a href="#Cache">type Cache</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewLRUCache">func NewLRUCache(capacity int) *Cache</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Cache.Close">func (c *Cache) Close()</a></dd>
				
			
				
				<dd><a href="#CompressionOpt">type CompressionOpt</a></dd>
				
				
			
				
				<dd><a href="#DB">type DB</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Open">func Open(dbname string, o *Options) (*DB, error)</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#DB.Close">func (db *DB) Close()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#DB.Delete">func (db *DB) Delete(wo *WriteOptions, key []byte) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#DB.Get">func (db *DB) Get(ro *ReadOptions, key []byte) ([]byte, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#DB.GetApproximateSizes">func (db *DB) GetApproximateSizes(ranges []Range) []uint64</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#DB.NewIterator">func (db *DB) NewIterator(ro *ReadOptions) *Iterator</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#DB.NewSnapshot">func (db *DB) NewSnapshot() *C.leveldb_snapshot_t</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#DB.PropertyValue">func (db *DB) PropertyValue(propName string) string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#DB.Put">func (db *DB) Put(wo *WriteOptions, key, value []byte) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#DB.ReleaseSnapshot">func (db *DB) ReleaseSnapshot(snap *C.leveldb_snapshot_t)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#DB.Write">func (db *DB) Write(wo *WriteOptions, w *WriteBatch) error</a></dd>
				
			
				
				<dd><a href="#DatabaseError">type DatabaseError</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#DatabaseError.Error">func (e DatabaseError) Error() string</a></dd>
				
			
				
				<dd><a href="#Env">type Env</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewDefaultEnv">func NewDefaultEnv() *Env</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Env.Close">func (env *Env) Close()</a></dd>
				
			
				
				<dd><a href="#Iterator">type Iterator</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Iterator.Close">func (it *Iterator) Close()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Iterator.GetError">func (it *Iterator) GetError() error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Iterator.Key">func (it *Iterator) Key() []byte</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Iterator.Next">func (it *Iterator) Next()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Iterator.Prev">func (it *Iterator) Prev()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Iterator.Seek">func (it *Iterator) Seek(key []byte)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Iterator.SeekToFirst">func (it *Iterator) SeekToFirst()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Iterator.SeekToLast">func (it *Iterator) SeekToLast()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Iterator.Valid">func (it *Iterator) Valid() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Iterator.Value">func (it *Iterator) Value() []byte</a></dd>
				
			
				
				<dd><a href="#IteratorError">type IteratorError</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#IteratorError.Error">func (e IteratorError) Error() string</a></dd>
				
			
				
				<dd><a href="#Options">type Options</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewOptions">func NewOptions() *Options</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Options.Close">func (o *Options) Close()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Options.SetBlockRestartInterval">func (o *Options) SetBlockRestartInterval(n int)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Options.SetBlockSize">func (o *Options) SetBlockSize(s int)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Options.SetCache">func (o *Options) SetCache(cache *Cache)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Options.SetComparator">func (o *Options) SetComparator(cmp *C.leveldb_comparator_t)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Options.SetCompression">func (o *Options) SetCompression(t CompressionOpt)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Options.SetCreateIfMissing">func (o *Options) SetCreateIfMissing(b bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Options.SetEnv">func (o *Options) SetEnv(env *Env)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Options.SetErrorIfExists">func (o *Options) SetErrorIfExists(error_if_exists bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Options.SetInfoLog">func (o *Options) SetInfoLog(log *C.leveldb_logger_t)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Options.SetMaxOpenFiles">func (o *Options) SetMaxOpenFiles(n int)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Options.SetParanoidChecks">func (o *Options) SetParanoidChecks(pc bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Options.SetWriteBufferSize">func (o *Options) SetWriteBufferSize(s int)</a></dd>
				
			
				
				<dd><a href="#Range">type Range</a></dd>
				
				
			
				
				<dd><a href="#ReadOptions">type ReadOptions</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewReadOptions">func NewReadOptions() *ReadOptions</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#ReadOptions.Close">func (ro *ReadOptions) Close()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ReadOptions.SetFillCache">func (ro *ReadOptions) SetFillCache(b bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ReadOptions.SetSnapshot">func (ro *ReadOptions) SetSnapshot(snap *C.leveldb_snapshot_t)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ReadOptions.SetVerifyChecksums">func (ro *ReadOptions) SetVerifyChecksums(b bool)</a></dd>
				
			
				
				<dd><a href="#WriteBatch">type WriteBatch</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewWriteBatch">func NewWriteBatch() *WriteBatch</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#WriteBatch.Clear">func (w *WriteBatch) Clear()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#WriteBatch.Close">func (w *WriteBatch) Close()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#WriteBatch.Delete">func (w *WriteBatch) Delete(key []byte)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#WriteBatch.Put">func (w *WriteBatch) Put(key, value []byte)</a></dd>
				
			
				
				<dd><a href="#WriteOptions">type WriteOptions</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewWriteOptions">func NewWriteOptions() *WriteOptions</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#WriteOptions.Close">func (wo *WriteOptions) Close()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#WriteOptions.SetSync">func (wo *WriteOptions) SetSync(b bool)</a></dd>
				
			
			
		</dl>

		

		
			<h4>Package files</h4>
			<p>
			<span style="font-size:90%">
			
				<a href="/target/batch.go">batch.go</a>
			
				<a href="/target/cache.go">cache.go</a>
			
				<a href="/target/comparator.go">comparator.go</a>
			
				<a href="/target/conv.go">conv.go</a>
			
				<a href="/target/db.go">db.go</a>
			
				<a href="/target/doc.go">doc.go</a>
			
				<a href="/target/env.go">env.go</a>
			
				<a href="/target/iterator.go">iterator.go</a>
			
				<a href="/target/options.go">options.go</a>
			
			</span>
			</p>
		
	
		
			<h2 id="constants">Constants</h2>
			
				<pre>const (
    NoCompression     = CompressionOpt(0)
    SnappyCompression = CompressionOpt(1)
)</pre>
				<p>
Known compression arguments for Options.SetCompression.
</p>

			
		
		
		
			
			
			<h2 id="DestroyComparator">func <a href="/target/comparator.go?s=268:319#L1">DestroyComparator</a></h2>
			<pre>func DestroyComparator(cmp *C.leveldb_comparator_t)</pre>
			<p>
DestroyComparator deallocates a *C.leveldb_comparator_t.
</p>
<p>
This is provided as a convienience to advanced users that have implemented
their own comparators in C in their own code.
</p>

			
		
			
			
			<h2 id="DestroyDatabase">func <a href="/target/db.go?s=1407:1460#L47">DestroyDatabase</a></h2>
			<pre>func DestroyDatabase(dbname string, o *Options) error</pre>
			<p>
DestroyDatabase removes a database entirely, removing everything from the
filesystem.
</p>

			
		
			
			
			<h2 id="RepairDatabase">func <a href="/target/db.go?s=1791:1843#L62">RepairDatabase</a></h2>
			<pre>func RepairDatabase(dbname string, o *Options) error</pre>
			<p>
RepairDatabase attempts to repair a database.
</p>
<p>
If the database is unrepairable, an error is returned.
</p>

			
		
		
			
			
			<h2 id="Cache">type <a href="/target/cache.go?s=537:584#L6">Cache</a></h2>
			<pre>type Cache struct {
    Cache *C.leveldb_cache_t
}</pre>
			<p>
Cache is a cache used to store data read from data in memory.
</p>
<p>
Typically, NewLRUCache() is all you will need, but advanced users may
implement their own *C.leveldb_cache_t and create a *Cache
</p>
<p>
To prevent memory leaks, a *Cache must have Close() called on it when it is
no longer needed by the program. Note: if the process is shutting down,
this may not be necessary and could be avoided to shorten shutdown time.
</p>


			

			

			

			
				
				<h3 id="NewLRUCache">func <a href="/target/cache.go?s=878:915#L15">NewLRUCache</a></h3>
				<pre>func NewLRUCache(capacity int) *Cache</pre>
				<p>
NewLRUCache creates a new Cache object with the capacity given.
</p>
<p>
To prevent memory leaks, Close() should be called on the *Cache when the
program no longer needs it. Note: if the process is shutting down, this may
not be necessary and could be avoided to shorten shutdown time.
</p>

				
			

			
				
				<h3 id="Cache.Close">func (*Cache) <a href="/target/cache.go?s=1051:1074#L20">Close</a></h3>
				<pre>func (c *Cache) Close()</pre>
				<p>
DestroyCache deallocates the underlying data of a Cache object.
</p>

				
				
			
		
			
			
			<h2 id="CompressionOpt">type <a href="/target/options.go?s=135:158#L1">CompressionOpt</a></h2>
			<pre>type CompressionOpt int</pre>
			<p>
CompressionOpt is a value for Options.SetCompression.
</p>


			

			

			

			

			
		
			
			
			<h2 id="DB">type <a href="/target/db.go?s=517:553#L15">DB</a></h2>
			<pre>type DB struct {
    Ldb *C.leveldb_t
}</pre>
			<p>
DB is a reusable handle to a LevelDB database on disk, created by Open.
</p>
<p>
To avoid memory and file descriptor leaks, call Close() when you are
through with the handle.
</p>
<p>
All methods on a DB instance are thread-safe except for Close(). Calls to
any DB method made after Close() will panic.
</p>


			

			

			

			
				
				<h3 id="Open">func <a href="/target/db.go?s=1021:1070#L33">Open</a></h3>
				<pre>func Open(dbname string, o *Options) (*DB, error)</pre>
				<p>
Open opens a database.
</p>
<p>
Creating a new database is done by calling SetCreateIfMissing(true) on the
*Options passed to Open.
</p>
<p>
It is usually wise to set a Cache object on the *Options with SetCache() to
keep recently used data from that database in memory.
</p>

				
			

			
				
				<h3 id="DB.Close">func (*DB) <a href="/target/db.go?s=7386:7407#L243">Close</a></h3>
				<pre>func (db *DB) Close()</pre>
				<p>
Close closes the database, rendering it unusable for I/O, by deallocating
the underlying handle.
</p>
<p>
Any attempts to use the DB after Close is called will panic.
</p>

				
				
			
				
				<h3 id="DB.Delete">func (*DB) <a href="/target/db.go?s=3872:3928#L138">Delete</a></h3>
				<pre>func (db *DB) Delete(wo *WriteOptions, key []byte) error</pre>
				<p>
Delete removes the data associated with the key from the database.
</p>
<p>
The key byte slice may be reused safely. Delete takes a copy of
them before returning.
</p>

				
				
			
				
				<h3 id="DB.Get">func (*DB) <a href="/target/db.go?s=3258:3320#L112">Get</a></h3>
				<pre>func (db *DB) Get(ro *ReadOptions, key []byte) ([]byte, error)</pre>
				<p>
Get returns the data associated with the key from the database.
</p>
<p>
If the key does not exist in the database, a nil []byte is returned. If the
key does exist, but the data is zero-length in the database, a zero-length
[]byte will be returned.
</p>
<p>
The key byte slice may be reused safely. Get takes a copy of
them before returning.
</p>

				
				
			
				
				<h3 id="DB.GetApproximateSizes">func (*DB) <a href="/target/db.go?s=5280:5338#L184">GetApproximateSizes</a></h3>
				<pre>func (db *DB) GetApproximateSizes(ranges []Range) []uint64</pre>
				<p>
GetApproximateSizes returns the approximate number of bytes of file system
space used by one or more key ranges.
</p>
<p>
The keys counted will begin at Range.Start and end on the key before
Range.Limit.
</p>

				
				
			
				
				<h3 id="DB.NewIterator">func (*DB) <a href="/target/db.go?s=4935:4987#L174">NewIterator</a></h3>
				<pre>func (db *DB) NewIterator(ro *ReadOptions) *Iterator</pre>
				<p>
NewIterator returns an *Iterator over the the database that uses the
ReadOptions given.
</p>
<p>
Often, this is used for large, offline bulk reads while serving live
traffic. In that case, it may be wise to disable caching so that the data
processed by the returned *Iterator does not displace the already cached
data. This can be done by calling SetFillCache(false) on the *ReadOptions
before passing it here.
</p>
<p>
Similiarly, *ReadOptions.SetSnapshot() is also useful.
</p>

				
				
			
				
				<h3 id="DB.NewSnapshot">func (*DB) <a href="/target/db.go?s=6912:6961#L229">NewSnapshot</a></h3>
				<pre>func (db *DB) NewSnapshot() *C.leveldb_snapshot_t</pre>
				<p>
NewSnapshot creates a new snapshot of the database.
</p>
<p>
The snapshot, when used in a ReadOptions, provides a consistent view of
state of the database at the the snapshot was created.
</p>
<p>
To prevent memory leaks and resource strain in the database, the snapshot
returned must be released with this DB&#39;s ReleaseSnapshot() method.
</p>
<p>
See the LevelDB C++ documentation docs for details.
</p>

				
				
			
				
				<h3 id="DB.PropertyValue">func (*DB) <a href="/target/db.go?s=6329:6380#L214">PropertyValue</a></h3>
				<pre>func (db *DB) PropertyValue(propName string) string</pre>
				<p>
PropertyValue returns the value of a database property.
</p>
<p>
Examples of properties include &#34;leveldb.stats&#34;, &#34;leveldb.sstables&#34;,
and &#34;leveldb.num-files-at-level0&#34;.
</p>

				
				
			
				
				<h3 id="DB.Put">func (*DB) <a href="/target/db.go?s=2325:2385#L81">Put</a></h3>
				<pre>func (db *DB) Put(wo *WriteOptions, key, value []byte) error</pre>
				<p>
Put writes data associated with a key to the database.
</p>
<p>
If a nil []byte is passed in as value, it will be returned by Get as an
zero-length slice.
</p>
<p>
The key and value byte slices may be reused safely. Put takes a copy of
them before returning.
</p>

				
				
			
				
				<h3 id="DB.ReleaseSnapshot">func (*DB) <a href="/target/db.go?s=7111:7168#L235">ReleaseSnapshot</a></h3>
				<pre>func (db *DB) ReleaseSnapshot(snap *C.leveldb_snapshot_t)</pre>
				<p>
ReleaseSnapshot removes the snapshot from the database&#39;s list of snapshots,
and deallocates it.
</p>

				
				
			
				
				<h3 id="DB.Write">func (*DB) <a href="/target/db.go?s=4234:4292#L155">Write</a></h3>
				<pre>func (db *DB) Write(wo *WriteOptions, w *WriteBatch) error</pre>
				<p>
Write atomically writes the *WriteBatch to disk.
</p>

				
				
			
		
			
			
			<h2 id="DatabaseError">type <a href="/target/db.go?s=123:148#L2">DatabaseError</a></h2>
			<pre>type DatabaseError string</pre>
			

			

			

			

			

			
				
				<h3 id="DatabaseError.Error">func (DatabaseError) <a href="/target/db.go?s=150:187#L4">Error</a></h3>
				<pre>func (e DatabaseError) Error() string</pre>
				
				
				
			
		
			
			
			<h2 id="Env">type <a href="/target/env.go?s=389:430#L4">Env</a></h2>
			<pre>type Env struct {
    Env *C.leveldb_env_t
}</pre>
			<p>
Env is a system call environment used by a database.
</p>
<p>
Typically, NewDefaultEnv is all you need. Advanced users may create their
own Env with a *C.leveldb_env_t of their own creation.
</p>
<p>
To prevent memory leaks, an *Env must have Close() called on it when it is
no longer needed by the program.
</p>


			

			

			

			
				
				<h3 id="NewDefaultEnv">func <a href="/target/env.go?s=587:612#L12">NewDefaultEnv</a></h3>
				<pre>func NewDefaultEnv() *Env</pre>
				<p>
NewDefaultEnv creates a default environment for use in an Options.
</p>
<p>
To prevent memory leaks, the Env returned should be deallocated with
Close.
</p>

				
			

			
				
				<h3 id="Env.Close">func (*Env) <a href="/target/env.go?s=724:747#L17">Close</a></h3>
				<pre>func (env *Env) Close()</pre>
				<p>
Close deallocates the Env, freeing the underlying struct.
</p>

				
				
			
		
			
			
			<h2 id="Iterator">type <a href="/target/iterator.go?s=1223:1275#L33">Iterator</a></h2>
			<pre>type Iterator struct {
    Iter *C.leveldb_iterator_t
}</pre>
			<p>
Iterator is a read-only iterator through a LevelDB database. It provides a
way to seek to specific keys and iterate through the keyspace from
that point, as well as access the values of those keys.
</p>
<p>
Care must be taken when using an Iterator. If the method Valid() returns
false, calls to Key(), Value(), Next(), and Prev() will result in
panics. However, Seek(), SeekToFirst(), SeekToLast(), GetError(), Valid()
and Close() will still be safe to call.
</p>
<p>
GetError() will only return an error in the event of a LevelDB error. It
will return a nil on iterators that are simply invalid. Given that
behavior, GetError() is not a replacement for a Valid().
</p>
<p>
A typical use looks like:
</p>
<pre>db := levigo.Open(...)

it := db.NewIterator(readOpts)
defer it.Close()
it.Seek(mykey)
for it = it; it.Valid(); it.Next() {
	useKeyAndValue(it.Key(), it.Value())
}
</pre>
<p>
To prevent memory leaks, an *Iterator must have Close() called on it when
it is no longer needed by the program.
</p>


			

			

			

			

			
				
				<h3 id="Iterator.Close">func (*Iterator) <a href="/target/iterator.go?s=3978:4005#L117">Close</a></h3>
				<pre>func (it *Iterator) Close()</pre>
				<p>
Close deallocates the given Iterator, freeing the underlying C struct.
</p>

				
				
			
				
				<h3 id="Iterator.GetError">func (*Iterator) <a href="/target/iterator.go?s=3720:3756#L107">GetError</a></h3>
				<pre>func (it *Iterator) GetError() error</pre>
				<p>
GetError() returns an error from LevelDB found while iterating.
</p>
<p>
This method is safe to call when Valid() returns false.
</p>

				
				
			
				
				<h3 id="Iterator.Key">func (*Iterator) <a href="/target/iterator.go?s=1618:1650#L46">Key</a></h3>
				<pre>func (it *Iterator) Key() []byte</pre>
				<p>
Key() returns a copy the key in the database the iterator currently holds.
</p>
<p>
If Valid() returns false, this method will panic.
</p>

				
				
			
				
				<h3 id="Iterator.Next">func (*Iterator) <a href="/target/iterator.go?s=2259:2285#L66">Next</a></h3>
				<pre>func (it *Iterator) Next()</pre>
				<p>
Next() moves the iterator to the next sequential key in the database, as
defined by the Comparator in the ReadOptions.
</p>
<p>
If Valid() returns false, this method will panic.
</p>

				
				
			
				
				<h3 id="Iterator.Prev">func (*Iterator) <a href="/target/iterator.go?s=2538:2564#L75">Prev</a></h3>
				<pre>func (it *Iterator) Prev()</pre>
				<p>
Prev() moves the iterator to the previous sequential key in the database,
as defined by the Comparator in the ReadOptions used to create this
Iterator.
</p>
<p>
If Valid() returns false, this method will panic.
</p>

				
				
			
				
				<h3 id="Iterator.Seek">func (*Iterator) <a href="/target/iterator.go?s=3463:3499#L100">Seek</a></h3>
				<pre>func (it *Iterator) Seek(key []byte)</pre>
				<p>
Seek() moves the iterator the position of the key given or, if the key
doesn&#39;t exist, the next key that does exist in the database. If the key
doesn&#39;t exist, and there is no next key, the Iterator becomes invalid.
</p>
<p>
This method is safe to call when Valid() returns false.
</p>

				
				
			
				
				<h3 id="Iterator.SeekToFirst">func (*Iterator) <a href="/target/iterator.go?s=2813:2846#L83">SeekToFirst</a></h3>
				<pre>func (it *Iterator) SeekToFirst()</pre>
				<p>
SeekToFirst() moves the iterator to the first key in the database, as
defined by the Comparator in the ReadOptions used to create this Iterator.
</p>
<p>
This method is safe to call when Valid() returns false.
</p>

				
				
			
				
				<h3 id="Iterator.SeekToLast">func (*Iterator) <a href="/target/iterator.go?s=3102:3134#L91">SeekToLast</a></h3>
				<pre>func (it *Iterator) SeekToLast()</pre>
				<p>
SeekToLast() moves the iterator to the last key in the database, as
defined by the Comparator in the ReadOptions used to create this Iterator.
</p>
<p>
This method is safe to call when Valid() returns false.
</p>

				
				
			
				
				<h3 id="Iterator.Valid">func (*Iterator) <a href="/target/iterator.go?s=1395:1427#L39">Valid</a></h3>
				<pre>func (it *Iterator) Valid() bool</pre>
				<p>
Valid() returns false only when an Iterator has iterated past either the
first or the last key in the database.
</p>

				
				
			
				
				<h3 id="Iterator.Value">func (*Iterator) <a href="/target/iterator.go?s=1918:1952#L56">Value</a></h3>
				<pre>func (it *Iterator) Value() []byte</pre>
				<p>
Value() returns a copy of the value in the database the iterator currently
holds.
</p>
<p>
If Valid() returns false, this method will panic.
</p>

				
				
			
		
			
			
			<h2 id="IteratorError">type <a href="/target/iterator.go?s=100:125#L1">IteratorError</a></h2>
			<pre>type IteratorError string</pre>
			

			

			

			

			

			
				
				<h3 id="IteratorError.Error">func (IteratorError) <a href="/target/iterator.go?s=127:164#L3">Error</a></h3>
				<pre>func (e IteratorError) Error() string</pre>
				
				
				
			
		
			
			
			<h2 id="Options">type <a href="/target/options.go?s=674:723#L15">Options</a></h2>
			<pre>type Options struct {
    Opt *C.leveldb_options_t
}</pre>
			<p>
Options represent all of the available options when opening a database with
Open(). Options should be created with NewOptions().
</p>
<p>
It is usually with to call SetCache() with a cache object. Otherwise, all
data will be read off disk.
</p>
<p>
To prevent memory leaks, DestroyOptions() must be called on an Options when
the program no longer needs it.
</p>


			

			

			

			
				
				<h3 id="NewOptions">func <a href="/target/options.go?s=1449:1475#L41">NewOptions</a></h3>
				<pre>func NewOptions() *Options</pre>
				<p>
NewOptions allocates a new Options object.
</p>
<p>
To prevent memory leaks, the *Options returned must have DestroyOptions()
called on it when it is no longer needed by the program.
</p>

				
			

			
				
				<h3 id="Options.Close">func (*Options) <a href="/target/options.go?s=2200:2225#L65">Close</a></h3>
				<pre>func (o *Options) Close()</pre>
				<p>
Close deallocates the Options, freeing its underlying C struct.
</p>

				
				
			
				
				<h3 id="Options.SetBlockRestartInterval">func (*Options) <a href="/target/options.go?s=4755:4803#L141">SetBlockRestartInterval</a></h3>
				<pre>func (o *Options) SetBlockRestartInterval(n int)</pre>
				<p>
SetBlockRestartInterval is the number of keys between restarts points for
delta encoding keys.
</p>
<p>
Most clients should leave this parameter alone.
</p>

				
				
			
				
				<h3 id="Options.SetBlockSize">func (*Options) <a href="/target/options.go?s=4503:4540#L133">SetBlockSize</a></h3>
				<pre>func (o *Options) SetBlockSize(s int)</pre>
				<p>
SetBlockSize sets the approximate size of user data packed per block.
</p>
<p>
See the LevelDB C++ documentation for details.
</p>

				
				
			
				
				<h3 id="Options.SetCache">func (*Options) <a href="/target/options.go?s=3074:3114#L91">SetCache</a></h3>
				<pre>func (o *Options) SetCache(cache *Cache)</pre>
				<p>
SetCache places a cache object in the database when a database is opened.
</p>
<p>
This is usually wise to use.
</p>

				
				
			
				
				<h3 id="Options.SetComparator">func (*Options) <a href="/target/options.go?s=2584:2644#L77">SetComparator</a></h3>
				<pre>func (o *Options) SetComparator(cmp *C.leveldb_comparator_t)</pre>
				<p>
SetComparator sets the comparator to be used for all read and write
operations.
</p>
<p>
The comparator that created a database must be the same one (technically,
one with the same name string) that is used to perform read and write
operations.
</p>
<p>
The default *C.leveldb_comparator_t is usually sufficient.
</p>

				
				
			
				
				<h3 id="Options.SetCompression">func (*Options) <a href="/target/options.go?s=5247:5297#L154">SetCompression</a></h3>
				<pre>func (o *Options) SetCompression(t CompressionOpt)</pre>
				<p>
SetCompression sets whether to compress blocks using the specified
compresssion algorithm.
</p>
<p>
The default value is SnappyCompression and it is fast
enough that it is unlikely you want to turn it off. The other option is
NoCompression.
</p>
<p>
If the LevelDB library was built without Snappy compression enabled, the
SnappyCompression setting will be ignored.
</p>

				
				
			
				
				<h3 id="Options.SetCreateIfMissing">func (*Options) <a href="/target/options.go?s=5455:5499#L160">SetCreateIfMissing</a></h3>
				<pre>func (o *Options) SetCreateIfMissing(b bool)</pre>
				<p>
SetCreateIfMissing causes Open to create a new database on disk if it does
not already exist.
</p>

				
				
			
				
				<h3 id="Options.SetEnv">func (*Options) <a href="/target/options.go?s=3228:3262#L96">SetEnv</a></h3>
				<pre>func (o *Options) SetEnv(env *Env)</pre>
				<p>
SetEnv sets the Env object for the new database handle.
</p>

				
				
			
				
				<h3 id="Options.SetErrorIfExists">func (*Options) <a href="/target/options.go?s=2812:2868#L83">SetErrorIfExists</a></h3>
				<pre>func (o *Options) SetErrorIfExists(error_if_exists bool)</pre>
				<p>
SetErrorIfExists, if passed true, will cause the opening of a database that
already exists to throw an error.
</p>

				
				
			
				
				<h3 id="Options.SetInfoLog">func (*Options) <a href="/target/options.go?s=3408:3461#L102">SetInfoLog</a></h3>
				<pre>func (o *Options) SetInfoLog(log *C.leveldb_logger_t)</pre>
				<p>
SetInfoLog sets a *C.leveldb_logger_t object as the informational logger
for the database.
</p>

				
				
			
				
				<h3 id="Options.SetMaxOpenFiles">func (*Options) <a href="/target/options.go?s=4276:4316#L126">SetMaxOpenFiles</a></h3>
				<pre>func (o *Options) SetMaxOpenFiles(n int)</pre>
				<p>
SetMaxOpenFiles sets the number of files than can be used at once by the
database.
</p>
<p>
See the LevelDB C++ documentation for details.
</p>

				
				
			
				
				<h3 id="Options.SetParanoidChecks">func (*Options) <a href="/target/options.go?s=4021:4065#L118">SetParanoidChecks</a></h3>
				<pre>func (o *Options) SetParanoidChecks(pc bool)</pre>
				<p>
SetParanoidChecks, when called with true, will cause the database to do
aggressive checking of the data it is processing and will stop early if it
detects errors.
</p>
<p>
See the LevelDB C++ documentation docs for details.
</p>

				
				
			
				
				<h3 id="Options.SetWriteBufferSize">func (*Options) <a href="/target/options.go?s=3681:3724#L109">SetWriteBufferSize</a></h3>
				<pre>func (o *Options) SetWriteBufferSize(s int)</pre>
				<p>
SetWriteBufferSize sets the number of bytes the database will build up in
memory (backed by an unsorted log on disk) before converting to a sorted
on-disk file.
</p>

				
				
			
		
			
			
			<h2 id="Range">type <a href="/target/db.go?s=696:745#L21">Range</a></h2>
			<pre>type Range struct {
    Start []byte
    Limit []byte
}</pre>
			<p>
Range is a range of keys in the database. GetApproximateSizes calls with it
begin at the key Start and end right before the key Limit.
</p>


			

			

			

			

			
		
			
			
			<h2 id="ReadOptions">type <a href="/target/options.go?s=932:989#L24">ReadOptions</a></h2>
			<pre>type ReadOptions struct {
    Opt *C.leveldb_readoptions_t
}</pre>
			<p>
ReadOptions represent all of the available options when reading from a
database.
</p>
<p>
To prevent memory leaks, DestroyReadOptions() must called on a ReadOptions
when the program no longer needs it
</p>


			

			

			

			
				
				<h3 id="NewReadOptions">func <a href="/target/options.go?s=1727:1761#L50">NewReadOptions</a></h3>
				<pre>func NewReadOptions() *ReadOptions</pre>
				<p>
NewReadOptions allocates a new ReadOptions object.
</p>
<p>
To prevent memory leaks, the *ReadOptions returned must have Close() called
on it when it is no longer needed by the program.
</p>

				
			

			
				
				<h3 id="ReadOptions.Close">func (*ReadOptions) <a href="/target/options.go?s=5640:5670#L165">Close</a></h3>
				<pre>func (ro *ReadOptions) Close()</pre>
				<p>
Close deallocates the ReadOptions, freeing its underlying C struct.
</p>

				
				
			
				
				<h3 id="ReadOptions.SetFillCache">func (*ReadOptions) <a href="/target/options.go?s=6351:6394#L183">SetFillCache</a></h3>
				<pre>func (ro *ReadOptions) SetFillCache(b bool)</pre>
				<p>
SetFillCache, when called with true, will cause all data read from
underlying storage to be placed in the database cache, if the cache exists.
</p>
<p>
It is useful to turn this off on ReadOptions that are used for
*DB.Iterator(), as it will prevent bulk scans from flushing out live user
data in the cache.
</p>

				
				
			
				
				<h3 id="ReadOptions.SetSnapshot">func (*ReadOptions) <a href="/target/options.go?s=6633:6695#L191">SetSnapshot</a></h3>
				<pre>func (ro *ReadOptions) SetSnapshot(snap *C.leveldb_snapshot_t)</pre>
				<p>
SetSnapshot causes reads to provided as they were when the passed in
Snapshot was created by *DB.NewSnapshot().
</p>
<p>
See the LevelDB C++ documentation for details.
</p>

				
				
			
				
				<h3 id="ReadOptions.SetVerifyChecksums">func (*ReadOptions) <a href="/target/options.go?s=5911:5960#L173">SetVerifyChecksums</a></h3>
				<pre>func (ro *ReadOptions) SetVerifyChecksums(b bool)</pre>
				<p>
SetVerifyChecksums, when called with true, will cause all data read from
underlying storage to verified against corresponding checksums.
</p>
<p>
See the LevelDB C++ documentation for details.
</p>

				
				
			
		
			
			
			<h2 id="WriteBatch">type <a href="/target/batch.go?s=347:405#L6">WriteBatch</a></h2>
			<pre>type WriteBatch struct {
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
WriteBatch is a batching of Puts, and Deletes to be written atomically to a
database. A WriteBatch is written when passed to *DB.Write().
</p>
<p>
To prevent memory leaks, call Close() when the program no longer needs the
WriteBatch object.
</p>


			

			

			

			
				
				<h3 id="NewWriteBatch">func <a href="/target/batch.go?s=463:495#L11">NewWriteBatch</a></h3>
				<pre>func NewWriteBatch() *WriteBatch</pre>
				<p>
NewWriteBatch creates a fully allocated *WriteBatch.
</p>

				
			

			
				
				<h3 id="WriteBatch.Clear">func (*WriteBatch) <a href="/target/batch.go?s=1629:1657#L45">Clear</a></h3>
				<pre>func (w *WriteBatch) Clear()</pre>
				<p>
Clear removes all the enqueued Put and Deletes in the *WriteBatch.
</p>

				
				
			
				
				<h3 id="WriteBatch.Close">func (*WriteBatch) <a href="/target/batch.go?s=620:648#L17">Close</a></h3>
				<pre>func (w *WriteBatch) Close()</pre>
				<p>
Close releases the underlying memory of a *WriteBatch.
</p>

				
				
			
				
				<h3 id="WriteBatch.Delete">func (*WriteBatch) <a href="/target/batch.go?s=1417:1456#L39">Delete</a></h3>
				<pre>func (w *WriteBatch) Delete(key []byte)</pre>
				<p>
Delete queues a deletion of the data at key to be deleted later.
</p>
<p>
The key byte slice may be reused safely. Delete takes a copy of
them before returning.
</p>

				
				
			
				
				<h3 id="WriteBatch.Put">func (*WriteBatch) <a href="/target/batch.go?s=878:921#L26">Put</a></h3>
				<pre>func (w *WriteBatch) Put(key, value []byte)</pre>
				<p>
Put places a key-value pair into the WriteBatch for writing later.
</p>
<p>
Both the key and value byte slices may be reused as WriteBatch takes a copy
of them before returning.
</p>

				
				
			
		
			
			
			<h2 id="WriteOptions">type <a href="/target/options.go?s=1202:1261#L33">WriteOptions</a></h2>
			<pre>type WriteOptions struct {
    Opt *C.leveldb_writeoptions_t
}</pre>
			<p>
WriteOptions represent all of the available options when writeing from a
database.
</p>
<p>
To prevent memory leaks, DestroyWriteOptions() must called on a
WriteOptions when the program no longer needs it
</p>


			

			

			

			
				
				<h3 id="NewWriteOptions">func <a href="/target/options.go?s=2024:2060#L59">NewWriteOptions</a></h3>
				<pre>func NewWriteOptions() *WriteOptions</pre>
				<p>
NewWriteOptions allocates a new WriteOptions object.
</p>
<p>
To prevent memory leaks, the *WriteOptions returned must have Close()
called on it when it is no longer needed by the program.
</p>

				
			

			
				
				<h3 id="WriteOptions.Close">func (*WriteOptions) <a href="/target/options.go?s=6823:6854#L196">Close</a></h3>
				<pre>func (wo *WriteOptions) Close()</pre>
				<p>
Close deallocates the WriteOptions, freeing its underlying C struct.
</p>

				
				
			
				
				<h3 id="WriteOptions.SetSync">func (*WriteOptions) <a href="/target/options.go?s=7409:7448#L209">SetSync</a></h3>
				<pre>func (wo *WriteOptions) SetSync(b bool)</pre>
				<p>
See the LevelDB C++ documentation for details.
</p>

				
				
			
		
		</div>
	

	







    </div> <!-- container -->
  </body>
</html>
